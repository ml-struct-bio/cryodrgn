"""Parse .star files generated by RELION v5 into 2D particle coordinates.

Example usage
-------------
cryodrgn_utils parse_relion -t tomograms.star -p particles.star --tilt-dim 5760 4092

"""
import argparse
import numpy as np
import pandas as pd
import starfile
from scipy.spatial.transform import Rotation as R
from ast import literal_eval


def add_args(parser: argparse.ArgumentParser) -> None:
    parser.add_argument(
        "-t", "--tomograms", required=True, help="Path to tomograms.star file."
    )
    parser.add_argument(
        "-p", "--particles", required=True, help="Path to main particles.star file."
    )
    parser.add_argument(
        "--tilt-dim",
        nargs=2,
        type=int,
        required=True,
        help="Tilt image dimensions in pixels, e.g. --tilt-dim 5760 4092",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="particles_2d.star",
        help="Output name for expanded 2D star file (default: %(default)s)",
    )


class Tomogram:
    """One tilt-series' geometry & defocus data.

    Precomputes a 4x4 transform (rotation + translation) that maps tomogram coordinates
    to each 2D tilt image.
    """

    def __init__(
        self,
        tilt_image_dims,
        pixel_size,
        defocus_u_array,
        defocus_v_array,
        defocus_angle_array,
        x_tilts,
        y_tilts,
        z_rots,
        x_shifts,
        y_shifts,
        hand,
    ):
        self.tilt_image_dims = tilt_image_dims
        self.pixel_size = pixel_size
        self.defocus_u_array = defocus_u_array
        self.defocus_v_array = defocus_v_array
        self.defocus_angle_array = defocus_angle_array
        self.x_tilts = x_tilts
        self.y_tilts = y_tilts
        self.z_rots = z_rots
        self.x_shifts = x_shifts
        self.y_shifts = y_shifts
        self.hand = hand

        self.n_tilts = len(self.x_tilts)
        self.projection_matrices = {}
        self._build_projection_matrices()

    def _translation_matrix(self, shift_3d):
        mat = np.eye(4)
        mat[:3, 3] = shift_3d
        return mat

    def _rotation_matrix(self, axis, angle_deg):
        """Build a 4x4 rotation about 'axis' by 'angle_deg' degrees."""
        rot = R.from_rotvec(np.deg2rad(angle_deg) * np.array(axis))
        mat = np.eye(4)
        mat[:3, :3] = rot.as_matrix()
        return mat

    def _build_projection_matrices(self):

        specimen_center = np.array([0, 0, 0])

        for i in range(self.n_tilts):
            s0 = self._translation_matrix(-specimen_center)
            r0 = self._rotation_matrix([1, 0, 0], self.x_tilts[i])
            r1 = self._rotation_matrix([0, 1, 0], self.y_tilts[i])
            r2 = self._rotation_matrix([0, 0, 1], self.z_rots[i])

            shift_in_angst = np.array([self.x_shifts[i], self.y_shifts[i], 0.0])
            s1 = self._translation_matrix(shift_in_angst)

            tilt_img_center = np.array(
                [self.tilt_image_dims[0] / 2.0, self.tilt_image_dims[1] / 2.0, 0.0]
            )
            s2 = self._translation_matrix(tilt_img_center)

            # M = s2 @ s1 @ r2 @ r1 @ r0 @ s0

            Rzyx = (
                R.from_matrix(r2[:3, :3])
                * R.from_matrix(r1[:3, :3])
                * R.from_matrix(r0[:3, :3])
            )
            R_inv = np.eye(4)
            R_inv[:3, :3] = Rzyx.inv().as_matrix()

            M = s2 @ s1 @ R_inv @ s0

            # if self.hand == -1:
            #     flip_z_4x4 = np.eye(4, dtype=np.float32)
            #     flip_z_4x4[2, 2] = -1
            #     M = flip_z_4x4 @ M

            self.projection_matrices[i] = M

    def project_point(self, point_3d, i_tilt):
        """
        Apply the 4x4 transformation for tilt i_tilt to project a 3D coordinate
        (in tomogram voxels) to 2D tilt coords.
        """
        pt_homog = np.append(point_3d, 1.0)
        M = self.projection_matrices[i_tilt]
        return (M @ pt_homog)[:2]

    def calculate_local_defocus_uv(self, i_tilt, point_3d):

        Rx = R.from_euler("x", self.x_tilts[i_tilt], degrees=True)
        Ry = R.from_euler("y", self.y_tilts[i_tilt], degrees=True)
        Rz = R.from_euler("z", self.z_rots[i_tilt], degrees=True)
        Rzyx = (Rz * Ry * Rx).as_matrix()

        proj_mat = np.eye(4)
        proj_mat[:3, :3] = Rzyx

        proj_mat[0, 3] = self.x_shifts[i_tilt]
        proj_mat[1, 3] = self.y_shifts[i_tilt]

        coords_ang = point_3d
        proj_pos = proj_mat @ np.append(coords_ang, 1.0)
        proj_centre = proj_mat @ np.array([0.0, 0.0, 0.0, 1.0])

        depth_offset = (proj_pos[2] - proj_centre[2]) * self.hand

        loc_u = self.defocus_u_array[i_tilt] + depth_offset
        loc_v = self.defocus_v_array[i_tilt] + depth_offset
        loc_angle = self.defocus_angle_array[i_tilt]

        return loc_u, loc_v, loc_angle

    def expand_particle_to_2drows(
        self,
        point_3d,
        original_image_name,
        tilt_series_df,
        group_name,
        base_orientation_zyz=None,
    ):

        coords_2d = []
        defocusU_list = []
        defocusV_list = []
        defocusAngle_list = []
        final_zyz_list = []

        for i in range(self.n_tilts):
            coords_2d.append(self.project_point(point_3d, i))
            lu, lv, la = self.calculate_local_defocus_uv(i, point_3d)
            defocusU_list.append(lu)
            defocusV_list.append(lv)
            defocusAngle_list.append(la)

            if base_orientation_zyz is not None:
                tilt_rot_3x3 = self.projection_matrices[i][:3, :3]
                R_final = R.from_matrix(base_orientation_zyz.as_matrix() @ tilt_rot_3x3)
                a, b, c = R_final.as_euler("ZYZ", degrees=True)
                final_zyz_list.append([a, b, c])

        coords_2d = np.array(coords_2d)
        final_zyz_list = np.array(final_zyz_list)

        # CTF scale factor from tilt_series_df or estimate from tilt angles
        if "rlnCtfScalefactor" in tilt_series_df.columns:
            ctf_scale = tilt_series_df["rlnCtfScalefactor"].to_numpy()
        else:
            ctf_scale = np.cos(np.deg2rad(tilt_series_df["rlnTomoYTilt"].to_numpy()))

        # Make 2D dataframe
        n_tilts = self.n_tilts
        image_names_2d = [f"{i+1:06d}@{original_image_name}" for i in range(n_tilts)]

        df_2d = pd.DataFrame(
            {
                "rlnMagnification": 10000.0,  # placeholder
                "rlnDefocusU": defocusU_list,
                "rlnDefocusV": defocusV_list,
                "rlnDefocusAngle": defocusAngle_list,
                "rlnImageName": image_names_2d,
                "rlnMicrographName": tilt_series_df["rlnMicrographName"].values,
                "rlnCoordinateX": coords_2d[:, 0],
                "rlnCoordinateY": coords_2d[:, 1],
                "rlnCtfBfactor": 0.0,  # placeholder - possibly remove
                "rlnCtfScalefactor": ctf_scale,
                "rlnGroupName": group_name,
                "rlnTiltName": tilt_series_df["rlnMicrographName"].values,
                "rlnTomoYTilt": tilt_series_df["rlnTomoYTilt"].values,
                "rlnMicrographPreExposure": tilt_series_df[
                    "rlnMicrographPreExposure"
                ].values,
            }
        )

        if base_orientation_zyz is not None and len(final_zyz_list) > 0:
            df_2d["rlnAngleRot"] = final_zyz_list[:, 0]
            df_2d["rlnAngleTilt"] = final_zyz_list[:, 1]
            df_2d["rlnAnglePsi"] = final_zyz_list[:, 2]
        else:
            df_2d["rlnAngleRot"] = 0.0
            df_2d["rlnAngleTilt"] = 0.0
            df_2d["rlnAnglePsi"] = 0.0

        df_2d = df_2d.sort_values(
            "rlnMicrographPreExposure", ascending=True
        ).reset_index(drop=True)
        return df_2d


def main(args: argparse.Namespace) -> None:
    """Running the command `cryodrgn_utils parse_relion` (see `add_args` above)."""

    # Load .star files
    tomo_star = starfile.read(args.tomograms, always_dict=True)
    particles_star = starfile.read(args.particles, always_dict=True)
    tomo_df = tomo_star["global"]
    particles_df = particles_star["particles"]
    optics_df = particles_star["optics"]
    tilt_series_cache = {}
    all_2d_rows = []
    tilt_image_dims = args.tilt_dim

    voltage = optics_df["rlnVoltage"].values[0]
    angpix = optics_df["rlnImagePixelSize"].values[0]
    cs = optics_df["rlnSphericalAberration"].values[0]
    w = optics_df["rlnAmplitudeContrast"].values[0]
    ps = 0

    for idx, row in particles_df.iterrows():
        tomo_name = row["rlnTomoName"]
        tomo_row = tomo_df[tomo_df["rlnTomoName"] == tomo_name].iloc[0]

        tilt_series_starfile = tomo_row["rlnTomoTiltSeriesStarFile"]
        if tomo_name not in tilt_series_cache:
            print(f"Loading tilt-series star for {tomo_name}: {tilt_series_starfile}")
            ts_star_dict = starfile.read(tilt_series_starfile, always_dict=True)
            first_key = list(ts_star_dict.keys())[0]
            ts_df = ts_star_dict[first_key]
            tilt_series_cache[tomo_name] = ts_df
        else:
            ts_df = tilt_series_cache[tomo_name]

        frames_list = row["rlnTomoVisibleFrames"]
        visible_indices = [
            i for i, val in enumerate(literal_eval(frames_list), start=1) if val == 1
        ]
        sub_ts_df = ts_df.iloc[[i - 1 for i in visible_indices]].copy()

        handedness = tomo_row.get("rlnTomoHand", 1)
        set_hand = -1 if handedness == -1 else 1

        x_tilts = sub_ts_df["rlnTomoXTilt"].to_numpy()
        y_tilts = sub_ts_df["rlnTomoYTilt"].to_numpy()
        z_rots = sub_ts_df["rlnTomoZRot"].to_numpy()
        x_shifts = sub_ts_df["rlnTomoXShiftAngst"].to_numpy()
        y_shifts = sub_ts_df["rlnTomoYShiftAngst"].to_numpy()

        defocusU_array = sub_ts_df["rlnDefocusU"].to_numpy()
        defocusV_array = sub_ts_df["rlnDefocusV"].to_numpy()
        defocusAngle_array = sub_ts_df["rlnDefocusAngle"].to_numpy()

        pixel_size_angstrom = tomo_row["rlnTomoTiltSeriesPixelSize"]

        tomogram = Tomogram(
            tilt_image_dims,
            pixel_size_angstrom,
            defocusU_array,
            defocusV_array,
            defocusAngle_array,
            x_tilts,
            y_tilts,
            z_rots,
            x_shifts,
            y_shifts,
            hand=set_hand,
        )

        # Particle orientation
        rot_particle = row["rlnAngleRot"]
        tilt_particle = row["rlnAngleTilt"]
        psi_particle = row["rlnAnglePsi"]
        R_particle = R.from_euler(
            "ZYZ", [rot_particle, tilt_particle, psi_particle], degrees=True
        )

        # Box orientation
        rot_subtomo = row.get("rlnTomoSubtomogramRot", 0.0)
        tilt_subtomo = row.get("rlnTomoSubtomogramTilt", 0.0)
        psi_subtomo = row.get("rlnTomoSubtomogramPsi", 0.0)
        R_subtomo = R.from_euler(
            "ZYZ", [rot_subtomo, tilt_subtomo, psi_subtomo], degrees=True
        )

        # Combined orientation from local->tomogram
        R_base = R_particle * R_subtomo
        x_ang = row["rlnCenteredCoordinateXAngst"]
        y_ang = row["rlnCenteredCoordinateYAngst"]
        z_ang = row["rlnCenteredCoordinateZAngst"]
        point_3d_rotated = np.array([x_ang, y_ang, z_ang])

        # Expand into 2D rows
        df_2d = tomogram.expand_particle_to_2drows(
            point_3d=point_3d_rotated,
            original_image_name=row["rlnImageName"],
            tilt_series_df=sub_ts_df,
            group_name=row["rlnTomoParticleName"],
            base_orientation_zyz=R_base,
        )

        # Add extra columns
        df_2d["rlnOriginalParticle"] = idx + 1
        df_2d["rlnRandomSubset"] = row["rlnRandomSubset"]
        df_2d["rlnDetectorPixelSize"] = angpix
        df_2d["rlnVoltage"] = voltage
        df_2d["rlnSphericalAberration"] = cs
        df_2d["rlnAmplitudeContrast"] = w
        df_2d["rlnPhaseShift"] = ps
        df_2d["rlnOriginX"] = 0
        df_2d["rlnOriginY"] = 0

        all_2d_rows.append(df_2d)

    final_2d_df = pd.concat(all_2d_rows, ignore_index=True)
    print(f"Total 2D rows in output: {len(final_2d_df)}")

    out_star_dict = {"": final_2d_df}
    starfile.write(out_star_dict, args.output, overwrite=True)
    print(f"Wrote {args.output}")
